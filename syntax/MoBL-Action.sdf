module MoBL-Action

imports
  Common
  MoBL-UI

exports

  context-free syntax %% Logic
    "function" QId "(" {FArg ","}* ")" ":" Type "{" Statement* "}" -> FunctionDef {cons("Function")}
    "function" QId "(" {FArg ","}* ")" "{" Statement* "}" -> FunctionDef {cons("FunctionNoReturnType")}
    "sync" "function" QId "(" {FArg ","}* ")" ":" Type "{" Statement* "}" -> FunctionDef {cons("SyncFunction")}
    "sync" "function" QId "(" {FArg ","}* ")" "{" Statement* "}" -> FunctionDef {cons("SyncFunctionNoReturnType")}
    
    FunctionDef -> Definition
    
  context-free syntax %% Statements
    "var" ID ":" Type "=" Exp ";"              -> Statement {cons("VarDecl")}
    "var" ID "=" Exp ";"                       -> Statement {cons("VarDeclInferred")}
    
    QId "=" Exp ";"                            -> Statement {cons("Assignment")}
    Exp ";"                                     -> Statement {cons("ExpStat")}
    "if" "(" Exp ")" "{" Statement* "}" "else" "{" Statement* "}" -> Statement {cons("If")}
    "if" "(" Exp ")" "{" Statement* "}"                  -> Statement {cons("IfNoElse")}
    "for" "(" ID ":" Type "in" Exp ")" "{" Statement* "}"  -> Statement {cons("For")}
    "return" Exp ";"                            -> Statement {cons("Return")}
    "screen" "return" Exp ";"                   -> Statement {cons("ScreenReturn")}
    "return" ";"                                -> Statement {cons("Return")}
    "screen" "return" ";"                       -> Statement {cons("ScreenReturn")}
    "async" "{" Statement* "}"                  -> Statement {cons("Async")}
    
  context-free syntax %% Expressions
  
    STRING                        -> Exp {cons("String")}
    INT                           -> Exp {cons("Int")}
    "true"                        -> Exp {cons("True")}
    "false"                       -> Exp {cons("False")}
    "null"                        -> Exp {cons("Null")}
    QId                           -> Exp {cons("Var")}
    QId "(" {NamedExp ","}* ")"   -> Exp {cons("Call")}
    Exp "." ID "(" {Exp ","}* ")" -> Exp {cons("MethodCall")}
    Exp "." ID                    -> Exp {cons("FieldAccess")}
    "uri" "(" Exp ")"             -> Exp {cons("Uri")}
    Exp "[" Exp "]"               -> Exp {left, cons("Indexer")}
    
    Exp                           -> NamedExp
    ID "=" Exp                    -> NamedExp {cons("NamedExp")}
    
    Exp BoolMethodId Exp         -> Exp {cons("BinMethodCall"), left}
    Exp CompareMethodId Exp      -> Exp {cons("BinMethodCall"), left}
    Exp TermOperatorMethodId Exp -> Exp {cons("BinMethodCall"), left}
    Exp OperatorMethodId Exp     -> Exp {cons("BinMethodCall"), left}
    
    Exp "?" Exp ":" Exp          -> Exp {left, cons("Choice")}
    ID "<" Type ">" "(" {Exp ","}* ")"      -> Exp {cons("CollectionCons")}
    Type "{" {PropVal ","}* "}"  -> Exp {cons("EntityCons")}
    "(" Exp ")"                  -> Exp {cons("Brackets")}
    
    "{" Statement* "}"             -> Exp {cons("Callback")}
    "template" "{" ScreenElem* "}" -> Exp {cons("AnonymousTemplate")}
    
    ID "=" Exp                  -> PropVal {cons("PropVal")}
    
  context-free syntax %% Filters
    "[" Exp Filter "]"                       -> Exp {cons("SetComp")}
    "where" SetExp                           -> Filter {cons("FilterNoOrderByNoLimit")}
    "order" "by" OrderExp                    -> Filter {cons("FilterNoWhereNoLimit")}
    "where" SetExp "order" "by" OrderExp     -> Filter {cons("FilterNoLimit")}
    "where" SetExp Limit                     -> Filter {cons("FilterNoOrderBy")}
    "order" "by" OrderExp Limit              -> Filter {cons("FilterNoWhere")}
    Limit                                    -> Filter {cons("FilterNoWhereNoOrderBy")}
    "where" Exp "order" "by" OrderExp Limit  -> Filter {cons("Filter")}
    Exp                                      -> OrderExp {cons("OrderNonSpecific")}
    Exp "asc"                                -> OrderExp {cons("OrderAscending")}
    Exp "desc"                               -> OrderExp {cons("OrderDescending")}
    "limit" Exp "offset" Exp                 -> Limit {cons("Limit")}
    "limit" Exp                              -> Limit {cons("LimitNoOffset")}
    "offset" Exp                             -> Limit {cons("LimitNoLimit")}
    
    ID "==" Exp                              -> SetExp {cons("SetEq")}
    ID "!=" Exp                              -> SetExp {cons("SetNotEq")}
    ID "<" Exp                               -> SetExp {cons("SetLt")}
    ID "<=" Exp                              -> SetExp {cons("SetLeq")}
    ID ">" Exp                               -> SetExp {cons("SetGt")}
    ID ">=" Exp                              -> SetExp {cons("SetGeq")}

    SetExp "&&" SetExp                       -> SetExp {left, cons("SetAnd")}
    
    
  context-free priorities
    Exp "." ID -> Exp
  > Exp TermOperatorMethodId Exp -> Exp
  > Exp OperatorMethodId Exp -> Exp
  > Exp CompareMethodId Exp -> Exp
  > Exp BoolMethodId Exp -> Exp

  context-free priorities  
  {
    ID "==" Exp                              -> SetExp
    ID "!=" Exp                              -> SetExp
    ID "<" Exp                               -> SetExp
    ID "<=" Exp                              -> SetExp
    ID ">" Exp                               -> SetExp
    ID ">=" Exp                              -> SetExp
  }
  > SetExp "&&" SetExp                       -> SetExp
  
  
  lexical syntax
    "||"                     -> BoolMethodId
    "&&"                     -> BoolMethodId
    "=="                     -> CompareMethodId
    "!="                     -> CompareMethodId
    "<"                      -> CompareMethodId
    "<="                     -> CompareMethodId
    ">"                      -> CompareMethodId
    ">="                     -> CompareMethodId
    "*"                      -> TermOperatorMethodId
    "/"                      -> TermOperatorMethodId
    "<<"                     -> TermOperatorMethodId
    ">>"                     -> TermOperatorMethodId
    "&"                      -> TermOperatorMethodId
    "|"                      -> TermOperatorMethodId
    "%"                      -> TermOperatorMethodId
    "+"                      -> OperatorMethodId
    "-"                      -> OperatorMethodId
    "++"                     -> PostFixId
    "--"                     -> PostFixId
    Id                       -> MethodId
    BoolMethodId             -> MethodId
    CompareMethodId          -> MethodId
    TermOperatorMethodId     -> MethodId
    OperatorMethodId         -> MethodId
    PostFixId                -> MethodId
    