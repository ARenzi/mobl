module check

imports
  include/MoBL
  lookup
  type
  rename
  desugar
  
rules
    
  constraint-error :
    t@SimpleType(_) -> (t, $[Type is not defined: [<write-to-string> t]])
    where not(<lookup-type> t) // no entity for this type
        ; not(_{"TemplateType"} := t)

  constraint-error :
    t@GenericType(_, _) -> (t, $[Type is not defined: [<write-to-string> t]])
    where not(<lookup-type> t) // no entity for this type
    
  constraint-error :
    Html(tag, _, _, closeTag) -> (closeTag, $[Wrong closing tag])
    where not(tag := closeTag)
    
  constraint-error :
    TemplateCall(qid, arg*, body) -> (qid, $[No such template defined with these arguments])
    where <map(type-of)> arg*
    where not("elements" := qid; [] := arg*)
    where not(<IsTemplateArgument> qid)
    where not(<lookup-template> qid)
    
  constraint-error :
    t@Var(qid) -> (t, $[Variable not defined])
    where not(type-of)

  constraint-error :
    t@FieldAccess(e, x) -> (t, $[Field [x] not defined])
    where <type-of> e
    where not(type-of)

  constraint-error :
    t@Call(qid, arg*) -> (t, $[Function not defined])
    where <map(type-of)> arg*
    where not(type-of)

  constraint-error :
    t@MethodCall(e, x, arg*) -> (t, $[No such method '[x]' defined])
    where <type-of> e
    where <map(type-of)> arg*
    where not(type-of)
  
  constraint-error = normalize; constraint-error
   
  constraint-warning:
    Entity(qid, _, _) -> (x, $[Entity names must start with a capital])
    where
      if <is-string> qid then
        x := qid
      else
        QId(_, x) := qid
      end
      ; not(<explode-string; Hd; is-upper> x)
  
/*  constraint-note:
    Module(x @ "example", _) -> (x, $[This is just an example program in the "entities" language
                                      (this note is defined in trans/check.str) ])
*/
  constraint-note = fail
