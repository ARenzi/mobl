module check

imports
  libstratego-lib
  include/MoBL
  lib/editor-common
  declare
  lookup
  type
  rename
  desugar
  mobl
  resolve

rules

  // Analysis: does a topdown traversal of the tree,
  // and try to apply the record-entity rule.
  analyze =
    ?Module(qid, _)
    ; {| ModuleName, Imports
       : rules ( ModuleName := qid )
       ; where(<debug> ["Analyzing module: ", qid])
       ; import-all
       ; alltd(add-tl-namespace)
       ; topdown(try(declare))
       ; alltd(add-namespace)
       ; rename-all
       ; where(<debug> "Done")
       |}

  store-result =
    ?t
    ; rules ( ResultingAST := t )

  import-all =
    alltd(import-module); topdown(try(flatten-list))
  
  import-module :
    Import(qid) -> def*
    with def* := <open-import(\ path -> <concat-strings> [<ProjectPath>, "/", path, ".mob"] \, parse-file, externalize-module)> <qid-to-path> qid
       ; rules ( Imports :+= qid )
    
  externalize-module :
    Module(qid, def*) -> def2*
    with def2* := <analyze; desugar-all; ?Module(_, <id>); map(definition-to-external <+ debug(!"Could not externalize: "); fail)>
    
  qid-to-path =
    is-string
  
  qid-to-path :
    QId(qid, x) -> $[[qids]/[x]]
    with qids := <qid-to-path> qid
    
strategies
  
  lookup-node :
    path -> <find-node> (path, <ResultingAST>)
    where debug(!"lookup-node: ")
                
  find-node :
    ([], t) -> t
  
  find-node :
    ([a|k], c#(ts)) -> <find-node> (k, <at-index(?result); !result> (a, ts)) 
    //where debug

rules
    
  constraint-error :
    t@SimpleType(_) -> (t, $[Type is not defined])
    where not(<lookup-type> t) // no entity for this type

  constraint-error :
    t@GenericType(_, _) -> (t, $[Type is not defined])
    where not(<lookup-type> t) // no entity for this type
    
  constraint-error :
    Html(tag, _, _, closeTag) -> (closeTag, $[Wrong closing tag])
    where not(tag := closeTag)
    
  constraint-error :
    TemplateCall(qid, arg*, prop*, body) -> (qid, $[No such template defined with these arguments])
    where not("elements" := qid; [] := arg*)
    where not(<lookup-template> (qid, <map(type-of)> arg*))
  
  constraint-error = normalize; constraint-error
  
  normalize :
    TemplateCallNoArgs(name, prop*, body) -> TemplateCall(name, [], prop*, body)

  normalize :
    TemplateCallNoArgsNoBody(name, prop*) -> TemplateCall(name, [], prop*, [])

  normalize :
    TemplateCallNoArgsNoProperties(name, body) -> TemplateCall(name, [], [], body)

  normalize :
    TemplateCallNoArgsNoPropertiesNoBody(name) -> TemplateCall(name, [], [], [])

  normalize :
    TemplateCallNoBody(name, arg*, prop*) -> TemplateCall(name, arg*, prop*, [])

  normalize :
    TemplateCallNoProperties(name, arg*, body) -> TemplateCall(name, arg*, [], body)

  normalize :
    TemplateCallNoPropertiesNoBody(name, arg*) -> TemplateCall(name, arg*, [], [])
  
  constraint-warning:
    Entity(x, _) -> (x, $[Entity names must start with a capital])
    where
      not(<explode-string; Hd; is-upper> x)
  
/*  constraint-note:
    Module(x @ "example", _) -> (x, $[This is just an example program in the "entities" language
                                      (this note is defined in trans/check.str) ])
*/
  constraint-note = fail