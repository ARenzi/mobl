module generation/action

imports
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/MoBL
  lib/editor-common
  desugar
  generation/emit
  generation/server
  generation/ui
  generation/cps-lift
  generation/cps-action
  generation/sql
  generation/data
  generation/compile
  generation/server
  rename
  declare
  lookup
  util
  editor/editor
  mobl

strategies

  module-to-js =
    (?Module(qid, def*) <+ ?Application(qid, _, def*) <+ ?ServerApplication(qid, _, def*))
    ; entities := <filter(?Entity(_, _, _, _))> def*
    ; rest := <filter(not(?Entity(_, _, _, _) <+ ?Import(_)))> def*
    ; to-import := <filter(not(?Import(_))); collect-om(?QId(<id>, _)); filter(not(?qid))> def*
    ; <map(import-to-js)> to-import
    ; <entities-to-js> entities
    ; <filter(definition-to-js)> rest
    ; <emit> $[[<qid-to-js> qid].isLoaded = true;]

strategies

  import-to-js :
    qid -> <emit> $[mobl.load('[<qid-to-path> qid].js');
]
	where not(ServerContext)

  definition-to-js :
    Load(path@Path(part*)) -> <id> //<emit> $[mobl.load('[<path-to-string> path]');]
    with path-str := <path-to-string> path
       ; <cut-off-last-element; separate-by(|"/"); <concat-strings> [<OutputPath>, "/"|<id>]; ensure-existing-dir> part*
        ; <copy-file> (<resolve-file> path-str, $[[<OutputPath>]/[path-str]])

  definition-to-js :
    Resource(path@Path(part*)) -> <id>
    with path-str := <path-to-string> path
       ; <cut-off-last-element; separate-by(|"/"); <concat-strings> [<OutputPath>, "/"|<id>]; ensure-existing-dir> part*
       ; <copy-file> (<resolve-file> path-str, $[[<OutputPath>]/[path-str]])

  path-to-string :
    Path(s*) -> <separate-by(|"/"); concat-strings> s*

  path-to-string :
    QuotedPath(s) -> <un-double-quote> s

  definition-to-js =
    function-to-js
    ; emit

  fargs-to-js =
    filter(farg-to-js)
    ; separate-by(!", ")
    ; concat-strings

  farg-to-js :
    FArg(x, _) -> x

  farg-to-js :
    FArgOptional(x, _, _) -> x

  fargs-to-init-js =
    map(farg-to-init-js)
    ; concat-strings

  farg-to-init-js :
    FArg(_, _) -> ""

  // TODO: This assumes that the expressions are all synchronous, needs to be checked!

  function-to-js :
    fn@SyncFunction(_, qid, _, _, _) -> <concat-strings> [varname, " = ", <function-to-js-exp> fn, ";\n"]
    with if <is-string> qid then
           varname := $[var [qid]]
         else
           varname := <qid-to-js> qid
         end

  function-to-js :
    fn@Function(_, qid, _, _, _) -> <concat-strings> [varname, " = ", <function-to-js-exp> fn, ";\n"]
    with if <is-string> qid then
           varname := $[var [qid]]
         else
           varname := <qid-to-js> qid
         end

  function-to-js-exp :
    SyncFunction(_, qid, farg*, rt, stat*) ->
     $[function([args]) {
         [stats]
       }]
    with qids := <qid-to-js> qid
       ; args := <fargs-to-js> farg*
       ; stats := <statements-to-js> stat*

  function-to-js-exp :
    Function(_, qid, farg*, rt, stats) ->
    $[function([args]) {
        [stats2]
      }]
    with qids := <qid-to-js> qid
       ; args := <filter(farg-to-js); <concat> [<id>, ["callback"]]; separate-by(!", "); concat-strings> farg*
       ; stats2 := <cps-lift-expressions; <concat> [<id>, [$[if(callback) callback(); return;]]]; cps-statements <+ debug(!"Could not translate to stats: "); fail> stats

rules // Statements

  statements-to-js =
    map(statement-to-js); separate-by(!"\n"); concat-strings

  statement-to-js =
    stat-to-js <+ debug(!"Could not translate statement: "); fail

  stat-to-js :
    ExpStat(e) -> $[[es];]
    with es := <expression-to-js> e

  stat-to-js :
    Return(e) -> $[return [es];]
    with es := <expression-to-js> e

  stat-to-js :
    ScreenReturn(e) -> $[screenCallback([es]);
                         return;]
    with es := <expression-to-js> e

  stat-to-js :
    VarDecl(x, t, e) -> $[var [x] = [<expression-to-js> e];]

  stat-to-js :
    VarDeclInferred(x, e) -> $[var [x] = [<expression-to-js> e];]

  stat-to-js :
    Block(stat*) ->
    $[{
        [<statements-to-js> stat*]
      }]

  stat-to-js :
    If(e, true-stat, false-stat) -> <concat-strings> ["if(", <expression-to-js> e, ") ", <statement-to-js> true-stat, " else ", <statement-to-js> false-stat]

  stat-to-js :
    For(lvalue, _, e, stat*) ->
      $[var [coll] = [<expression-to-js> e];
        var [length] = [coll].length;
        for(var [i] = 0; [i] < [length]; [i]++) {
          [vardecls]
          [assigns]
          [<statements-to-js> stat*]
        }]
    with coll := <newname> "coll"
       ; length := <newname> "length"
       ; i := <newname> "i"
       ; vardecls := <map(!$[var [<id>]; ]); concat-strings> <lvalue-vars> lvalue
       ; assigns := <desugar-all; (map(statement-to-js); concat-strings <+ statement-to-js)> Assignment(lvalue, MethodCall(Var(coll), "get", [Var(i)]))

  stat-to-js :
    While(e, stat*) ->
      $[while([<expression-to-js> e]) {
          (function() {
            [<statements-to-js> stat*]
          }());
        }]

  stat-to-js :
    Assignment(qid, e) -> $[[<qid-to-js> qid].set([<expression-to-js> e]);]
    where <is-ref> qid

  stat-to-js :
    Assignment(qid, e) -> $[[<qid-to-js> qid] = [<expression-to-js> e];]
    where <is-string> qid
    where not(<is-ref> qid)

  stat-to-js :
    Assignment(LFieldAccess(le, x), e) -> $[[<exp-to-js> le].[x] = [<expression-to-js> e];]

rules // Expressions
  expression-to-js =
    exp-to-js <+ debug(!"Could not translate: "); fail

  ref-expression-to-js =
    ref-exp-to-js <+ !$[ref([<expression-to-js>])]

  exp-to-js :
    String(s) -> s

  exp-to-js :
    Num(n) -> n

  exp-to-js :
    True() -> $[true]

  exp-to-js :
    False() -> $[false]

  exp-to-js :
    Null() -> $[null]

  exp-to-js :
    Tuple(e, []) -> <concat-strings> ["new mobl.Tuple(", <expression-to-js> e, ")"]

  exp-to-js :
    Tuple(e, e*) -> <concat-strings> ["new mobl.Tuple(", <expression-to-js> e, ", ", <map(expression-to-js); separate-by(!", "); concat-strings> e*, ")"]
    where not([] := e*)

  exp-to-js :
    List(e*) -> <concat-strings> ["[", <map(expression-to-js); separate-by(!", "); concat-strings> e*, "]"]

  /*ref-exp-to-js :
    Var(qid) -> $[ref(scope, '[<qid-to-js> qid]')]
    where not(<is-ref> qid)*/

  exp-to-js :
    Not(e) -> $[![<expression-to-js> e]]

  exp-to-js :
    Var(qid) -> <qid-to-js> qid
    where not(<is-ref> qid)

  exp-to-js :
    Var(qid) -> $[[qid].get()]
    where <is-ref> qid

  ref-exp-to-js :
    Var(qid) -> qid
    where <is-ref> qid

  exp-to-js :
    Var(qid) -> $[[<qid-to-js> qid].get()]
    where <is-ref> qid

  exp-to-js :
    Call(qid, e*) -> $[[<qid-to-js> qid]([args])]
    where not(<lookup-type> SimpleType(qid))
    with args := <arguments-to-js; separate-by(!", "); concat-strings> e*

  exp-to-js :
    Call(qid, named-e*) -> $[new [<qid-to-js> qid]({[propvals]})]
    where ExternalEntity(_, _, _, _) := <lookup-type> SimpleType(qid)
    with propvals := <map(\ NamedExp(x, e) -> $['[x]': [<expression-to-js> e]] \); separate-by(!", "); concat-strings> named-e*

  exp-to-js :
    Call(qid, named-e*) -> $[mobl.instantiate([<qid-to-js> qid], {[propvals]})]
    where ExternalType(_, _, _, _) := <lookup-type> SimpleType(qid)
    with propvals := <map(\ NamedExp(x, e) -> $['[x]': [<expression-to-js> e]] \); separate-by(!", "); concat-strings> named-e*

  exp-to-js :
    MethodCall(e, x, e*) -> $[[es].[x]([args])]
    with args := <map(expression-to-js); separate-by(!", "); concat-strings> e*
       ; es := <expression-to-js> e

  ref-exp-to-js :
    Indexer(e, idxe) -> $[ref([es], [idxes])]
    with es := <ref-expression-to-js> e
       ; idxes := <expression-to-js> idxe

  exp-to-js :
    Indexer(e, idxe) -> ${{es}[{idxes}]}
    with es := <expression-to-js> e
       ; idxes := <expression-to-js> idxe

  exp-to-js :
    CollectionCons(QId("mobl", "Collection"), _, e*) -> $[new persistence.LocalQueryCollection($[$[args]$]$)]
    with args := <map(expression-to-js); separate-by(!", "); concat-strings> e*

  exp-to-js :
    CollectionCons(QId("mobl", "Array"), _, e*) -> $[$[$[args]$]$]
    with args := <map(expression-to-js); separate-by(!", "); concat-strings> e*

  exp-to-js :
    CollectionCons(QId("mobl", "Map"), _, e*) -> $[new mobl.Map()]

  exp-to-js :
    EntityCons(SimpleType(qid), propval*) -> $[new [<qid-to-js> qid]({[propvals]})]
    with propvals := <map(\ PropVal(x, e) -> $['[x]': [<expression-to-js> e]] \); separate-by(!", "); concat-strings> propval*

  ref-exp-to-js :
    FieldAccess(e, x) -> $[ref([es], '[x]')]
    with es := <ref-expression-to-js> e

  exp-to-js :
    FieldAccess(e, x) -> $[[es].[x]]
    with es := <expression-to-js> e

  ref-exp-to-js :
    Brackets(e) -> $[([es])]
    with es := <ref-expression-to-js> e

  exp-to-js :
    Brackets(e) -> $[([es])]
    with es := <expression-to-js> e

  exp-to-js :
    BinMethodCall(e1, op, e2) -> $[[e1s] [op] [e2s]]
    with e1s := <expression-to-js> e1
       ; e2s := <expression-to-js> e2

  exp-to-js :
    RegExp(r) -> $[/[<pp-mobl-string; trim-whitespace> r]/]

  exp-to-js :
    Choice(e, e-true, e-false) -> $[[<expression-to-js> e] ? [<expression-to-js> e-true] : [<expression-to-js> e-false]]

  exp-to-js :
    Callback(stat*) -> $[function(event) {
                           if(event && event.stopPropagation) event.stopPropagation();
                           [<cps-lift-expressions; cps-statements> stat*]
                         }]


  exp-to-js :
    AnonymousControl(elems) -> $[function(elements, callback) {
                                    var [root] = $("<span>");
                                    [body]
                                  }]
    with {| InControl
          : rules ( InControl := 1 )
          ; root := <newname> "root"
          ; body := <elems-to-js-callback(|root)> elems
          |}

strategies

  arguments-to-js :
    arg* -> <map(expression-to-js)> arg*
    /*with
      {| Arg
       : normal-args := <filter(not(?NamedExp(_,_)); expression-to-js <+ rules ( Arg :+= <id>); fail )> arg*
       ; named := <bagof-Arg>
       |}
       ; named-args := <map(\ NamedExp(x, e) -> $['[x]': [<expression-to-js> e]] \)> named*/

  ref-arguments-to-js :
    arg* -> <map(ref-expression-to-js)> arg*
    /*with
      {| Arg
       : normal-args := <filter(not(?NamedExp(_,_)); ref-expression-to-js <+ rules ( Arg :+= <id>); fail )> arg*
       ; named := <bagof-Arg>
       |}
       ; named-args := <map(\ NamedExp(x, e) -> $['[x]': [<ref-expression-to-js> e]] \)> named*/

rules // util
  qid-to-js :
    s -> s
    where is-string

  qid-to-js :
    QId(qid, x) -> $[[qids].[x]]
    where not(ServerContext)
    with qids := <qid-to-js> qid
