module generation/server

imports
  include/MoBL
  analyze
  declare
  rename
  desugar
  mobl
  editor/editor
  generation/compile
  generation/emit
  generation/ui
  generation/action
  generation/data
  generation/script
  generation/html
  generation/service
  generation/type
  include/MoBL
  lib/editor-common
  sync-analysis
  util
  pp

strategies

  compile =
      (?ServerApplication(qid, setting*, def*); ?app <+ where(ServerContext); ?Module(qid, def*))
      ; where(<debug(!"Now compiling: ")> <pp-mobl-qid> qid
              ; rules ( Compiled : qid )
              ; include-paths := <IncludePaths>)
      ; with({| ServerContext, OutputPath, IncludePaths
         : rules ( ServerContext := True()
                   OutputPath    := <ServerOutputPath>
                   IncludePaths := [<concat-strings> [<plugin-path>, "/stdlib-server"]|include-paths])
         ; analyze
         ; where(alltd(compile-import-module))
         ; desugar-all
         ; module-to-js
         |})
      ; where(path := <debug(!"Qid: "); qid-to-dot-path> qid
              ; js-filename   := <concat-strings> [<ServerOutputPath>, "/", path, ".js"]
              ; <dirname; ensure-existing-dir> js-filename)
      ; fp := <fopen> (js-filename, "w")
      ; <fputs> ($[var [<qid-to-js-server> qid] = {};
], fp)
      ; if !app then
          <fputs> ($[
var connect = require('connect');
var express = require('express');

global.app = express.createServer(
  connect.bodyDecoder(),
  connect.staticProvider('.')
);
], fp)
        end
      ; <fputs> (<get-all>, fp)
      ; if !app then
          <fputs> ($[
global.app.listen(8888);
console.log('Server running at http://127.0.0.1:8888/');
], fp)
        else
          <fputs> ($[exports.[<qid-to-js-server> qid] = [<qid-to-js-server> qid];
], fp)
        end
      ; <fclose> fp

  qid-to-js :
    QId(qid, x) -> $[[qids].[x]]
    where ServerContext
    with qids := <qid-to-js-server> qid

  qid-to-js-server :
    QId(qid, x) -> $[[qids]__[x]]
    with qids := <qid-to-js-server> qid

  qid-to-js-server :
    s -> s
    where is-string

  import-to-js :
    qid -> <emit> $[var [<qid-to-js-server> qid] = require('./[<qid-to-dot-path> qid]').[<qid-to-js-server> qid];
]
  where ServerContext

  definition-to-js :
    Load(path@Path(part*)) -> <emit> $[var [ns] = require('./[<path-to-string> path]').[ns];]
    where ServerContext
    with path-str := <path-to-string> path
       ; <cut-off-last-element; separate-by(|"/"); <concat-strings> [<OutputPath>, "/"|<id>]; ensure-existing-dir> part*
       ; <copy-file> (<resolve-file> path-str, $[[<OutputPath>]/[path-str]])
       ; ns := <at-last(?last); !last; ?[<id>]; string-tokenize(|<explode-string> "."); cut-off-last-element; separate-by(|"."); concat-strings> part*

strategies

  function-to-js :
    fn@SyncFunction(manno*, qid, _, _, _) -> <concat-strings> [varname, " = ", <function-to-js-exp> fn, ";\n", <expose-service <+ debug(!"Could not expose: ")> (type, uri, varname)]
    where <fetch(?ServiceAnno(type, uri))> manno*
    with if <is-string> qid then
           varname := $[var [qid]]
         else
           varname := <qid-to-js> qid
         end

  function-to-js :
    fn@Function(manno*, qid, _, _, _) -> <concat-strings> [varname, " = ", <function-to-js-exp> fn, ";\n", <expose-service <+ debug(!"Could not expose: "); fail> (type, uri, varname)]
    where <fetch(?ServiceAnno(type, uri))> manno*
    with if <is-string> qid then
           varname := $[var [qid]]
         else
           varname := <qid-to-js> qid
         end

  expose-service :
    (GetMethod(), UriPath(part*), varname) -> $[global.app.get('/[<map(uri-part-to-string); separate-by(|"/")> part*]', [varname]);]

  expose-service :
    (PostMethod(), UriPath(part*), varname) -> $[global.app.post('/[<map(uri-part-to-string); separate-by(|"/")> part*]', [varname]);]

  expose-service :
    (PutMethod(), UriPath(part*), varname) -> $[global.app.put('/[<map(uri-part-to-string); separate-by(|"/")> part*]', [varname]);]

  uri-part-to-string :
    UriPart(s) -> s

  uri-part-to-string :
    UriVar(s) -> $[:[s]]

rules

  qid-to-dot-path :
    s -> s
    where is-string

  qid-to-dot-path :
    QId(qid, x) -> $[[<qid-to-dot-path> qid].[x]]
