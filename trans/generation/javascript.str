module generation/javascript

imports
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/MoBL
  lib/editor-common
  desugar
  generation/emit
  generation/html
  generation/cps-javascript
  rename
  declare

strategies

  definitions-to-js =
    where(alltd(definition-to-js))
    
  definition-to-js :
    Import(qid) -> <emit-js> $[mobiworks.requires('[<qid-to-js> qid]');
]

  definition-to-js :
    Entity(qid, prop*) -> <emit-js> $[
    [varname] = persistence.define('[<qid-to-html> qid]', {
      [props]
    });
    ]
    with props := <map(property-to-js); separate-by(!",\n"); concat-strings> prop*
       ; if <is-string> qid then
           varname := $[var [qid]]
         else
           varname := <qid-to-js> qid
         end

  property-to-js :
    Property(x, t) -> $['[x]': '[sqlType]']
    with sqlType := "TEXT"

  definition-to-js :
    SyncFunction(qid, farg*, rt, stat*) -> <emit-js> $[
    [varname] = function([args]) {
      [stats]
    };
    ]
    with qids := <qid-to-js> qid
       ; args := <map(?FArg(<id>, _)); separate-by(!", "); concat-strings> farg*
       ; {| InSyncFunction
          : rules ( InSyncFunction := 1 )
          ; stats := </*cps-lift-expressions; debug; */statements-to-js> stat*
         |}
       ; if <is-string> qid then
			     varname := $[var [qid]]
			   else
			     varname := <qid-to-js> qid
			   end

  definition-to-js :
    Function(qid, farg*, rt, stat*) -> <emit-js> $[
    [varname] = function([args]) {
      [stats]
    };
    ]
    with qids := <qid-to-js> qid
       ; args := <map(?FArg(<id>, _)); <concat> [<id>, ["callback"]]; separate-by(!", "); concat-strings> farg*
       ; stats := <cps-lift-expressions; debug; cps-statements> stat*
       //; <debug> <cps-lift-expressions> stat*
       ; if <is-string> qid then
           varname := $[var [qid]]
         else
           varname := <qid-to-js> qid
         end
			  
rules // Statements

  statements-to-js =
    map(statement-to-js); separate-by(!"\n"); concat-strings
  
  statement-to-js =
    stat-to-js <+ debug(!"Could not translate statement: "); fail
  
  stat-to-js :
    ExpStat(e) -> $[[es];]
    with es := <expression-to-js> e

  stat-to-js :
    Return(e) -> $[return [es];]
    where InSyncFunction
    with es := <expression-to-js> e

  stat-to-js :
    VarDecl(x, t, e) -> $[var [x] = [<expression-to-js> e];]
    where not(InTemplate)

  stat-to-js :
    VarDeclInferred(x, e) -> $[var [x] = [<expression-to-js> e];]
    where not(InTemplate)

  stat-to-js :
    VarDecl(x, t, e) -> $[var [x] = [<expression-to-js> e];]

  stat-to-js :
    If(e, true-stat*, false-stat*) -> 
      $[if([<expression-to-js> e]) {
          [<statements-to-js> true-stat*]
        } else {
          [<statements-to-js> false-stat*]
        }]

  stat-to-js :
    Assignment(qid, e) -> $[[<qid-to-js> qid].set([<expression-to-js> e]);]
    where <is-ref> qid

  stat-to-js :
    Assignment(qid, e) -> $[[<qid-to-js> qid] = [<expression-to-js> e];]
    where not(<is-ref> qid)
    
rules // Expressions
  expression-to-js =
    exp-to-js <+ debug(!"Could not translate: "); fail
    
  ref-expression-to-js =
    ref-exp-to-js <+ !$[ref([<expression-to-js>])]
  
  ref-exp-to-js :
    String(s) -> $[ref([s])]

  ref-exp-to-js :
    Int(n) -> $[ref([n])]

  exp-to-js :
    String(s) -> s

  exp-to-js :
    Int(n) -> n
  
  exp-to-js :
    Var(qid) -> $[fromScope(this, '[<qid-to-js> qid]')]
    where <InTemplate> qid
        ; <is-string> qid
        ; not(<is-ref> qid)

  exp-to-js :
    Var(qid) -> <qid-to-js> qid
    where not(<InTemplate> qid; <is-string> qid)
        ; not(<is-ref> qid)

  exp-to-js :
    Var(qid) -> $[fromScope(this, '[qid]').get()]
    where <InTemplate> qid
        ; <is-string> qid
        ; <is-ref> qid
          
  exp-to-js :
    Var(qid) -> $[[<qid-to-js> qid].get()]
    where not(<InTemplate> qid; <is-string> qid)
        ; <is-ref> qid

  ref-exp-to-js :
    Var(qid) -> $[ref(fromScope(this), '[qid]')]
    where <InTemplate> qid
        ; <is-string> qid
        ; not(<is-ref> qid)

  ref-exp-to-js :
    Var(qid) -> $[fromScope(this, '[qid]')]
    where <InTemplate> qid
        ; <is-string> qid
        ; <is-ref> qid
  
  exp-to-js :
    Call(qid, e*) -> $[[<qid-to-js> qid]([args])]
    with args := <map(expression-to-js); separate-by(!", "); concat-strings> e*

  /*exp-to-js :
    Call(qid, e*) -> $[[qids]([args], function(result) {
      [reststats]
    })]
    where not(<IsSyncFunction> qid)
    with qids := <qid-to-js> qid
       ; args := <map(expression-to-js); separate-by(!", "); concat-strings> e**/
         

  ref-exp-to-js :
    Indexer(e, idxe) -> $[ref([es], [idxes])]
    with es := <expression-to-js> e
       ; idxes := <expression-to-js> idxe

  exp-to-js :
    Indexer(e, idxe) -> ${{es}[{idxes}]}
    with es := <expression-to-js> e
       ; idxes := <expression-to-js> idxe
         
  exp-to-js :
    CollectionCons(_, _, e*) -> $[new persistence.LocalQueryCollection([args])]
    with args := <map(expression-to-js); separate-by(!", "); concat-strings> e*
  
  exp-to-js :
    EntityCons(SimpleType(qid), propval*) -> $[new [<qid-to-js> qid]({[propvals]})]
    with propvals := <map(\ PropVal(x, e) -> $['[x]': [<expression-to-js> e]] \); separate-by(!", "); concat-strings> propval*
      
  ref-exp-to-js :
    FieldAccess(e, x) -> $[ref([es], '[x]')]
    with es := <expression-to-js> e

  exp-to-js :
    FieldAccess(e, x) -> $[[es].[x]]
    with es := <expression-to-js> e

  ref-exp-to-js :
    Brackets(e) -> $[([es])]
    with es := <ref-expression-to-js> e

  exp-to-js :
    Brackets(e) -> $[([es])]
    with es := <expression-to-js> e
    
  exp-to-js :
    BinMethodCall(e1, op, e2) -> $[[e1s] [op] [e2s]]
    with e1s := <expression-to-js> e1
       ; e2s := <expression-to-js> e2
  
rules // util
  qid-to-js :
    s -> s
    where is-string
  
  qid-to-js :
    QId(qid, x) -> $[[qids].[x]]
    with qids := <qid-to-js> qid