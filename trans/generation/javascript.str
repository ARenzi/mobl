module generation/javascript

imports
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/MoBL
  lib/editor-common
  desugar
  generation/emit
  generation/html

strategies

  definitions-to-js =
    where(alltd(definition-to-js))

  definition-to-js :
    Entity(qid, prop*) -> <emit-js> $[
    [varname] = persistence.define('[<qid-to-html> qid]', {
      [props]
    });
    ]
    with props := <map(property-to-js); separate-by(!",\n"); concat-strings> prop*
       ; if <is-string> qid then
           varname := $[var [qid]]
         else
           varname := <qid-to-js> qid
         end

  property-to-js :
    Property(x, t) -> $['[x]': '[sqlType]']
    with sqlType := "TEXT"

  definition-to-js :
    Function(qid, farg*, rt, stat*) -> <emit-js> $[
    [varname] = function([args]) {
      [stats]
    };
    ]
    with qids := <qid-to-js> qid
       ; args := <map(?FArg(<id>, _)); separate-by(!", "); concat-strings> farg*
       ; stats := <statements-to-js> stat*
       ; if <is-string> qid then
			     varname := $[var [qid]]
			   else
			     varname := <qid-to-js> qid
			   end
			  
rules // Statements

  statements-to-js =
    map(statement-to-js)
  
  statement-to-js =
    stat-to-js <+ debug(!"Could not translate statement: "); fail
  
  stat-to-js :
    ExpStat(e) -> $[[es];
]
    with es := <expression-to-js> e

  stat-to-js :
    Return(e) -> $[return [es];
]
    with es := <expression-to-js> e
    
rules // Expressions
  expression-to-js =
    exp-to-js <+ debug(!"Could not translate: "); fail
  
  exp-to-js :
    String(s) -> s

  exp-to-js :
    Int(n) -> n
  
  exp-to-js :
    Var(qid) -> <qid-to-js> qid
  
  exp-to-js :
    Call(qid, e*) -> $[[qids]([args])]
    with qids := <qid-to-js> qid
       ; args := <map(expression-to-js); separate-by(!", "); concat-strings> e*

  exp-to-js :
    MethodCall(e, x, e*) -> $[[es].[x]([args])]
    with es := <expression-to-js> e
       ; args := <map(expression-to-js); separate-by(!", "); concat-strings> e*
  
  exp-to-js :
    Indexer(e, idxe) -> ${{es}[{idxes}]}
    with es := <expression-to-js> e
       ; idxes := <expression-to-js> idxe

  exp-to-js :
    Brackets(e) -> $[([es])]
    with es := <expression-to-js> e
    
  exp-to-js :
    BinMethodCall(e1, op, e2) -> $[[e1s] [op] [e2s]]
    with e1s := <expression-to-js> e1
       ; e2s := <expression-to-js> e2
                

rules // util
  qid-to-js :
    s -> s
    where is-string
  
  qid-to-js :
    QId(qid, x) -> $[[qids].[x]]
    with qids := <qid-to-js> qid