module generation/html

imports
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/MoBL
  lib/editor-common
  desugar
  generation/emit
  generation/javascript
  generation/cps-javascript

rules

  definitions-to-html =
    where(alltd(definition-to-html))

  props-to-html :
    [] -> ""
  
  props-to-html :
    [PropertyArg(x, String(s))|k] -> $[ [x]=[s][rest]]
    with rest := <props-to-html> k 

  props-to-html :
    [PropertyArg(x, e)|k] -> $[ [x]=[<expression-to-html> e][rest]]
    where not(String(_) := e)
    with rest := <props-to-html> k 

  definition-to-html :
    Template(qid, farg*, req*, elems) -> <emit-js> $[
      mobiworks.rootScope.setLocal('[<qid-to-html> qid]', function([fargs]) {
        var [root] = $("<span>");
        [body] 
      });
      ]
    with {| InTemplate
		      : rules ( InTemplate := 1 )
		      ; root := <newname> "root"
		      ; body-elem := <elems-to-js-callback(|root)> elems
		      ; fargs :=  <map(?FArg(<id>, _)); <concat> [["scope"], <id>, ["callback"]]; separate-by(!", "); concat-strings> farg*
		      ; init-stat* := <filter(?Init(<id>)); concat> elems
		      ; if not([] := init-stat*) then
		          init-fn := <newname> "init"
		          ; <emit-js> $[
		              function [init-fn](scope, callback) {
		                [<cps-lift-expressions; cps-statements> init-stat*]
		              }
		            ]
              ; body := $[
                  [init-fn](scope, function() {
                    [body-elem]
                  });
              ]
		        else
		          body := body-elem
		        end
		      |}

  definition-to-html :
    Screen(qid, farg*, rt, elem*) -> <definition-to-html> Template(qid, farg*, SimpleType(QId("mobl", "void")), elem*)

  elems-to-js-callback(|root) =
    <concat; elems-to-js(|root)> [<id>, [$[callback([root]);]]]
    

  elems-to-js(|root) :
    [TemplateCall(qid, arg*, prop*, elems)|rest*] -> $[
      var [subScope] = new mobiworks.LinkedMap(scope);
      [body-stats]
      (scope.get('[<qid-to-html> qid]'))([args]);
    ]
    with elem-root := <newname> "root"
       ; subScope := <newname> "subScope"
       ; if not([] := elems) then
           body-stats := $[
             [subScope].setLocal('elements', function(scope, callback) {
               var [elem-root] = $("<span>");
               [<elems-to-js-callback(|elem-root)> elems]
             });
             ]
         else
           body-stats := ""
         end
       ; if not([] := prop*) then
           props := <map(prop-to-bind)> prop* //, function() { [<expression-to-js> e]; });
//] where debug(!"ANother: ") \ <+ debug(!"Could not convert property: "); fail)> prop*
           ; prop-set := $[
               var children = node.children();
               for(var i = 0; i < children.length; i++) {
                  var c = children.eq(i);
                  [props]
               }]
         else
           prop-set := ""
         end
       ; args  := <map(ref-expression-to-js); <concat> [[subScope], <id>, [
           $[function(node) {
               [prop-set]
               [root].append(node.contents());
               [<elems-to-js(|root)> rest*]
             }]
         ]]; separate-by(!", "); concat-strings> arg*
  
  prop-to-bind :
    PropertyArg(x, e) -> $[c.bind('[x]', function() { [<expression-to-js> e]; });]
  
  elems-to-js(|root) :
    [Html(tag, arg*, elems, _)|rest*] -> $[
      var [node] = $("<[tag] [<escape> args]>");
      [<filter(databind-tag-arg-to-js(|tag, node)); concat-strings> arg*]
      [body]
    ]
    with args := <filter(tag-arg-to-html); separate-by(!" "); concat-strings> arg*
       ; node := <newname> "node"
       ; body := <elems-to-js(|node)> <concat> [elems, [
           $[[root].append([node]);
           [<elems-to-js(|root)> rest*]]]]

  elems-to-js(|root) :
    [s|rest*] -> $[[s][<elems-to-js(|root)> rest*]]
    where <is-string> s
  
  elems-to-js(|root) :
    [] -> ""

  
  tag-arg-to-html :
    HtmlArg(name, s) -> $[[name]=[s]]

  databind-tag-arg-to-js(|tag, node) :
    HtmlDatabindArg(e) -> $[
      var [r] = [es];
      [node].[method]([r].get());
      [r].addSetListener(function(val) {
        [node].[method](val);
      });
    ]
    with es := <ref-expression-to-js> e
       ; r  := <newname> "ref"
       ; if "input" := tag then
           method := "val"
         else
           method := "text"
         end
    
  /*elem-to-js :
    List(x, t, e, elem*) -> $[<ul databind=[es] item="[x]">[body]</ul>]
    with es := <ref-expression-to-html> e
       ; body := <elems-to-js> elem**/
    
  elems-to-js(|root) :
    [ScreenString(s)|rest*] -> $[
      [root].append([s]);
      [<elems-to-js(|root)> rest*]]
    
  ref-expression-to-html :
    e -> $["[<ref-expression-to-js; html-escape> e]"]

  expression-to-html :
    e -> $["[<expression-to-js; html-escape> e]"]
  
  html-escape =
    string-replace(|"\"", "&quot;")

rules // utils
	
  qid-to-html :
    s -> s
    where is-string

  qid-to-html :
    QId(qid, x) -> $[[qids]__[x]]
    with qids := <qid-to-html> qid	