module generation/html

imports
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/MoBL
  lib/editor-common
  desugar
  generation/emit
  generation/javascript

rules

  definitions-to-html =
    where(alltd(definition-to-html))

  props-to-html :
    [] -> ""
  
  props-to-html :
    [PropertyArg(x, s)|k] -> $[ [x]=[s][rest]]
    with rest := <props-to-html> k 

  elems-to-html =
    filter(elem-to-html)
    ; concat-strings

  definition-to-html :
    Screen(qid, args, rt, elem*) -> <emit-html> $[<div class="template" id="[<qid-to-html> qid]" [fargs][init]>[body]</div>
]
    with {| InTemplate
		      : rules ( InTemplate := 1 )
		      ; body := <elems-to-html> elem*
		      ; fargs := <map-with-index(farg-to-html); separate-by(!" "); concat-strings> args
		      ; init-stat* := <filter(?Init(<id>)); concat> elem*
		      ; if not([] := init-stat*) then
		          init-fn-name := <newname> "init"
		          ; init := $[ oninit="[init-fn-name]"]
		          ; <emit-js> $[
		              function [init-fn-name](scope) {
		                 [<statements-to-js> init-stat*]
		              }
		            ]
		        else
		          init := ""
		        end
		      |}

  definition-to-html :
    Template(qid, args, req*, elem*) -> <emit-html> $[<div class="template" id="[<qid-to-html> qid]" [fargs]>[body]</div>
]
    with {| InTemplate
          : rules ( InTemplate := 1 )
          ; fargs := <map-with-index(farg-to-html <+ debug(!"FAIL: "); fail); separate-by(!" "); concat-strings> args
          ; body := <elems-to-html> elem*
          |}

  farg-to-html :
    (idx, FArg(x, t)) -> $[farg[<subti> (idx, 1)]="[x]"]

  args-to-html =
    map-with-index(arg-to-html)
    ; concat-strings
    
  arg-to-html :
    (idx, e) -> $[arg[<subti> (idx, 1)]=[<ref-expression-to-html> e]]

  elem-to-html :
    TemplateCall(qid, arg*, prop*, elem*) -> $[<div class="templatecall" template="[<qid-to-html> qid]" [args] [props]>[body]</div>]
    with props := <props-to-html> prop*
       ; body  := <elems-to-html> elem*
       ; args  := <args-to-html> arg*
  
  elem-to-html :
    Html(tag, arg*, elem*, _) -> $[<[tag] [args]>[body]</[tag]>]
    with args := <map(tag-arg-to-html); separate-by(!" "); concat-strings> arg*
       ; body := <elems-to-html> elem*

  elem-to-html :
    HtmlShort(tag, arg*) -> $[<[tag] [args]/>]
    with args := <map(tag-arg-to-html); separate-by(!" "); concat-strings> arg*
  
  tag-arg-to-html :
    HtmlArg(name, s) -> $[[name]=[s]]

  tag-arg-to-html :
    HtmlDatabindArg(e) -> $[databind=[es]]
    with es := <ref-expression-to-html> e
    
  elem-to-html :
    List(x, t, e, elem*) -> $[<ul databind=[es] item="[x]">[body]</ul>]
    with es := <ref-expression-to-html> e
       ; body := <elems-to-html> elem*
    
  elem-to-html :
    ScreenString(s) -> <un-double-quote> s
    
  ref-expression-to-html :
    e -> $["[<ref-expression-to-js; html-escape> e]"]
  
  html-escape =
    string-replace(|"\"", "&quot;")

rules // utils
	
  qid-to-html :
    s -> s
    where is-string

  qid-to-html :
    QId(qid, x) -> $[[qids]__[x]]
    with qids := <qid-to-html> qid	